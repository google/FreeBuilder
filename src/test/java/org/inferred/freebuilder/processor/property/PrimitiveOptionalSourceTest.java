/*
 * Copyright 2015 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.inferred.freebuilder.processor.property;

import static org.inferred.freebuilder.processor.GeneratedTypeSubject.assertThat;
import static org.inferred.freebuilder.processor.NamingConvention.BEAN;
import static org.inferred.freebuilder.processor.model.ClassTypeImpl.newTopLevelClass;
import static org.inferred.freebuilder.processor.source.FunctionalType.primitiveUnaryOperator;

import com.google.common.collect.ImmutableMap;

import org.inferred.freebuilder.processor.BuilderFactory;
import org.inferred.freebuilder.processor.Datatype;
import org.inferred.freebuilder.processor.GeneratedBuilder;
import org.inferred.freebuilder.processor.NamingConvention;
import org.inferred.freebuilder.processor.model.ClassTypeImpl;
import org.inferred.freebuilder.processor.model.PrimitiveTypeImpl;
import org.inferred.freebuilder.processor.property.PrimitiveOptionalProperty.OptionalType;
import org.inferred.freebuilder.processor.source.QualifiedName;
import org.inferred.freebuilder.processor.source.feature.GuavaLibrary;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.util.Optional;

@RunWith(JUnit4.class)
public class PrimitiveOptionalSourceTest {

  @Test
  public void testJ8() {
    assertThat(builder(BEAN)).given(GuavaLibrary.AVAILABLE).generates(
        "// Autogenerated code. Do not modify.",
        "package com.example;",
        "",
        "import com.example.Item;",
        "import com.google.common.annotations.VisibleForTesting;",
        "import java.util.Objects;",
        "import java.util.OptionalDouble;",
        "import java.util.OptionalInt;",
        "import java.util.function.DoubleUnaryOperator;",
        "import java.util.function.IntUnaryOperator;",
        "",
        "/** Auto-generated superclass of {@link Item.Builder}, "
            + "derived from the API of {@link Item}. */",
        "abstract class Item_Builder {",
        "",
        "  /** Creates a new builder using {@code value} as a template. */",
        "  public static Item.Builder from(Item value) {",
        "    return new Item.Builder().mergeFrom(value);",
        "  }",
        "",
        "  private OptionalInt cost = OptionalInt.empty();",
        "  private OptionalDouble tax = OptionalDouble.empty();",
        "",
        "  /**",
        "   * Sets the value to be returned by {@link Item#getCost()}.",
        "   *",
        "   * @return this {@code Builder} object",
        "   */",
        "  public Item.Builder setCost(int cost) {",
        "    this.cost = OptionalInt.of(cost);",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /**",
        "   * Sets the value to be returned by {@link Item#getCost()}.",
        "   *",
        "   * @return this {@code Builder} object",
        "   * @throws NullPointerException if {@code cost} is null",
        "   */",
        "  public Item.Builder setCost(OptionalInt cost) {",
        "    if (cost.isPresent()) {",
        "      return setCost(cost.getAsInt());",
        "    } else {",
        "      return clearCost();",
        "    }",
        "  }",
        "",
        "  /**",
        "   * If the value to be returned by {@link Item#getCost()} is present, "
            + "replaces it by applying",
        "   * {@code mapper} to it and using the result.",
        "   *",
        "   * @return this {@code Builder} object",
        "   * @throws NullPointerException if {@code mapper} is null",
        "   */",
        "  public Item.Builder mapCost(IntUnaryOperator mapper) {",
        "    Objects.requireNonNull(mapper);",
        "    cost.ifPresent(value -> setCost(mapper.applyAsInt(value)));",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /**",
        "   * Sets the value to be returned by {@link Item#getCost()} to "
            + "{@link OptionalInt#empty()}.",
        "   *",
        "   * @return this {@code Builder} object",
        "   */",
        "  public Item.Builder clearCost() {",
        "    cost = OptionalInt.empty();",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /** Returns the value that will be returned by {@link Item#getCost()}. */",
        "  public OptionalInt getCost() {",
        "    return cost;",
        "  }",
        "",
        "  /**",
        "   * Sets the value to be returned by {@link Item#getTax()}.",
        "   *",
        "   * @return this {@code Builder} object",
        "   */",
        "  public Item.Builder setTax(double tax) {",
        "    this.tax = OptionalDouble.of(tax);",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /**",
        "   * Sets the value to be returned by {@link Item#getTax()}.",
        "   *",
        "   * @return this {@code Builder} object",
        "   * @throws NullPointerException if {@code tax} is null",
        "   */",
        "  public Item.Builder setTax(OptionalDouble tax) {",
        "    if (tax.isPresent()) {",
        "      return setTax(tax.getAsDouble());",
        "    } else {",
        "      return clearTax();",
        "    }",
        "  }",
        "",
        "  /**",
        "   * If the value to be returned by {@link Item#getTax()} is present, "
            + "replaces it by applying {@code",
        "   * mapper} to it and using the result.",
        "   *",
        "   * @return this {@code Builder} object",
        "   * @throws NullPointerException if {@code mapper} is null",
        "   */",
        "  public Item.Builder mapTax(DoubleUnaryOperator mapper) {",
        "    Objects.requireNonNull(mapper);",
        "    tax.ifPresent(value -> setTax(mapper.applyAsDouble(value)));",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /**",
        "   * Sets the value to be returned by {@link Item#getTax()} to "
            + "{@link OptionalDouble#empty()}.",
        "   *",
        "   * @return this {@code Builder} object",
        "   */",
        "  public Item.Builder clearTax() {",
        "    tax = OptionalDouble.empty();",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /** Returns the value that will be returned by {@link Item#getTax()}. */",
        "  public OptionalDouble getTax() {",
        "    return tax;",
        "  }",
        "",
        "  /** Sets all property values using the given {@code Item} as a template. */",
        "  public Item.Builder mergeFrom(Item value) {",
        "    value.getCost().ifPresent(this::setCost);",
        "    value.getTax().ifPresent(this::setTax);",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /**",
        "   * Copies values from the given {@code Builder}. "
            + "Does not affect any properties not set on the",
        "   * input.",
        "   */",
        "  public Item.Builder mergeFrom(Item.Builder template) {",
        "    template.getCost().ifPresent(this::setCost);",
        "    template.getTax().ifPresent(this::setTax);",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /** Resets the state of this builder. */",
        "  public Item.Builder clear() {",
        "    Item_Builder defaults = new Item.Builder();",
        "    cost = defaults.cost;",
        "    tax = defaults.tax;",
        "    return (Item.Builder) this;",
        "  }",
        "",
        "  /** Returns a newly-created {@link Item} based on the contents of the "
            + "{@code Builder}. */",
        "  public Item build() {",
        "    return new Value(this);",
        "  }",
        "",
        "  /**",
        "   * Returns a newly-created partial {@link Item} for use in unit tests. "
            + "State checking will not be",
        "   * performed.",
        "   *",
        "   * <p>Partials should only ever be used in tests. "
            + "They permit writing robust test cases that won't",
        "   * fail if this type gains more application-level constraints "
            + "(e.g. new required fields) in",
        "   * future. If you require partially complete values in production code, "
            + "consider using a Builder.",
        "   */",
        "  @VisibleForTesting()",
        "  public Item buildPartial() {",
        "    return new Partial(this);",
        "  }",
        "",
        "  private static class Value extends Item {",
        "    private final OptionalInt cost;",
        "    private final OptionalDouble tax;",
        "",
        "    private Value(Item_Builder builder) {",
        "      cost = builder.cost;",
        "      tax = builder.tax;",
        "    }",
        "",
        "    @Override",
        "    public OptionalInt getCost() {",
        "      return cost;",
        "    }",
        "",
        "    @Override",
        "    public OptionalDouble getTax() {",
        "      return tax;",
        "    }",
        "",
        "    @Override",
        "    public boolean equals(Object obj) {",
        "      if (obj == null || !getClass().equals(obj.getClass())) {",
        "        return false;",
        "      }",
        "      Value other = (Value) obj;",
        "      return Objects.equals(cost, other.cost) && Objects.equals(tax, other.tax);",
        "    }",
        "",
        "    @Override",
        "    public int hashCode() {",
        "      return Objects.hash(cost, tax);",
        "    }",
        "",
        "    @Override",
        "    public String toString() {",
        "      StringBuilder result = new StringBuilder(\"Item{\");",
        "      String separator = \"\";",
        "      if (cost.isPresent()) {",
        "        result.append(\"cost=\").append(cost.getAsInt());",
        "        separator = \", \";",
        "      }",
        "      if (tax.isPresent()) {",
        "        result.append(separator).append(\"tax=\").append(tax.getAsDouble());",
        "      }",
        "      return result.append(\"}\").toString();",
        "    }",
        "  }",
        "",
        "  private static class Partial extends Value {",
        "",
        "    Partial(Item_Builder builder) {",
        "      super(builder);",
        "    }",
        "",
        "    @Override",
        "    public String toString() {",
        "      return \"partial \" + super.toString();",
        "    }",
        "  }",
        "}");
  }

  private static GeneratedBuilder builder(NamingConvention convention) {
    ClassTypeImpl optionalInt = newTopLevelClass("java.util.OptionalInt");
    ClassTypeImpl optionalDouble = newTopLevelClass("java.util.OptionalDouble");
    QualifiedName person = QualifiedName.of("com.example", "Item");
    QualifiedName generatedBuilder = QualifiedName.of("com.example", "Item_Builder");

    Datatype datatype = new Datatype.Builder()
        .setBuilder(person.nestedType("Builder").withParameters())
        .setExtensible(true)
        .setBuilderFactory(BuilderFactory.NO_ARGS_CONSTRUCTOR)
        .setBuilderSerializable(false)
        .setGeneratedBuilder(generatedBuilder.withParameters())
        .setInterfaceType(false)
        .setPartialType(generatedBuilder.nestedType("Partial").withParameters())
        .setPropertyEnum(generatedBuilder.nestedType("Property").withParameters())
        .setType(person.withParameters())
        .setValueType(generatedBuilder.nestedType("Value").withParameters())
        .build();
    Property cost = new Property.Builder()
        .setAllCapsName("COST")
        .setCapitalizedName("Cost")
        .setFullyCheckedCast(true)
        .setGetterName((convention == BEAN) ? "getCost" : "cost")
        .setName("cost")
        .setType(optionalInt)
        .setUsingBeanConvention(convention == BEAN)
        .build();
    Property tax = new Property.Builder()
        .setAllCapsName("TAX")
        .setCapitalizedName("Tax")
        .setFullyCheckedCast(true)
        .setGetterName((convention == BEAN) ? "getTax" : "tax")
        .setName("tax")
        .setType(optionalDouble)
        .setUsingBeanConvention(convention == BEAN)
        .build();

    return new GeneratedBuilder(datatype, ImmutableMap.of(
        cost, new PrimitiveOptionalProperty(
            datatype,
            cost,
            OptionalType.INT,
            Optional.of(primitiveUnaryOperator(PrimitiveTypeImpl.INT)),
            Optional.empty()),
        tax, new PrimitiveOptionalProperty(
            datatype,
            tax,
            OptionalType.DOUBLE,
            Optional.of(primitiveUnaryOperator(PrimitiveTypeImpl.DOUBLE)),
            Optional.empty())));
  }
}
